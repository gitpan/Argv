<HTML>
<HEAD>
<TITLE>Argv Module</TITLE>
<LINK REV="made" HREF="mailto:dsb@sparc5.boyski.com">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A>
	<LI><A HREF="#RAISON_D_ETRE">RAISON D'ETRE</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<LI><A HREF="#FUNCTIONAL_INTERFACE">FUNCTIONAL INTERFACE</A>
	<LI><A HREF="#CONSTRUCTOR">CONSTRUCTOR</A>
	<LI><A HREF="#METHODS">METHODS</A>
	<UL>

		<LI><A HREF="#INSTANCE_METHODS">INSTANCE METHODS</A>
		<LI><A HREF="#EXECUTION_METHODS">EXECUTION METHODS</A>
		<LI><A HREF="#EXECUTION_ATTRIBUTES">EXECUTION ATTRIBUTES</A>
	</UL>

	<LI><A HREF="#PORTING">PORTING</A>
	<LI><A HREF="#AUTHOR">AUTHOR</A>
	<LI><A HREF="#COPYRIGHT">COPYRIGHT</A>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
Argv - Provide an O-O interface to an ARGV

<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
<PRE>    use Argv;
</PRE>
<P>
<PRE>    # A roundabout way of getting perl's version.
    my $pl = Argv-&gt;new(qw(perl -v));
    $pl-&gt;exec;
</PRE>
<P>
<PRE>    # Run /bin/cat, showing how to provide &quot;predigested&quot; options.
    Argv-&gt;new('/bin/cat', [qw(-u -n)], @ARGV)-&gt;system;
</PRE>
<P>
<PRE>    # A roundabout way of globbing.
    my $echo = Argv-&gt;new(qw(echo M*));
    $echo-&gt;glob;
    my $globbed = $echo-&gt;qx;
    print &quot;'echo M*' globs to: $globbed&quot;;
</PRE>
<P>
<PRE>    # A demonstration of the builtin xargs-like behavior.
    my @files = split(/\s+/, $globbed);
    my $ls = Argv-&gt;new(qw(ls -d -l), @files);
    $ls-&gt;parse(qw(d l));
    $ls-&gt;dbglevel(1);
    $ls-&gt;qxargs(1);
    my @long = $ls-&gt;qx;
    $ls-&gt;dbglevel(0);
    print @long;
</PRE>
<P>
<PRE>    # A demonstration of how to use option sets in a wrapper program.
    @ARGV = qw(Who -a -y foo -r);       # hack up an @ARGV
    my $who = Argv-&gt;new(@ARGV);         # instantiate
    $who-&gt;dbglevel(1);                  # set verbosity
    $who-&gt;optset(qw(UNAME FOO WHO));    # define 3 option sets
    $who-&gt;parseUNAME(qw(a m n p));      # parse these to set UNAME
    $who-&gt;parseFOO(qw(y=s z));          # parse -y and -z to FOO
    $who-&gt;parseWHO('r');                # for the 'who' cmd
    warn &quot;got -y flag in option set FOO\n&quot; if $who-&gt;flagFOO('y');
    print Argv-&gt;new('uname', $who-&gt;optsUNAME)-&gt;qx;
    $who-&gt;prog(lc $who-&gt;prog);          # force $0 to lower case
    $who-&gt;exec(qw(WHO));                # exec the who cmd
</PRE>
<P>
More advanced examples can be lifted from the test script or the ./examples
subdirectory.

<P>
<HR>
<H1><A NAME="RAISON_D_ETRE">RAISON D'ETRE</A></H1>
<P>
This module presents an O-O approach to command lines, allowing you to
instantiate an 'argv object', manipulate it, and eventually run it, e.g.:

<P>
<PRE>    my $ls = Argv-&gt;new('ls', ['-l']));
    my $rc = $ls-&gt;system;       # or $ls-&gt;exec or $ls-&gt;qx
</PRE>
<P>
Which raises the immediate question - what value does this mumbo-jumbo add
over Perl's native support, e.g.:

<P>
<PRE>    my $rc = system(qw(ls -l));
</PRE>
<P>
The answer comes in a few parts:

<UL>
<LI><STRONG><A NAME="item_STRUCTURE">STRUCTURE</A></STRONG>
<P>
First, Argv recognizes the underlying property of an arg vector, which is
that it begins with a program name potentially followed by options, then
operands. An Argv object factors a raw argv into these three groups,
provides accessor methods to allow operations on each group independently,
and can then put them back together for execution.

<LI><STRONG><A NAME="item_OPTION">OPTION SETS</A></STRONG>
<P>
Second, Argv encapsulates and extends <CODE>Getopt::Long</CODE> to allow parsing of the argv's options into different <EM>option sets</EM>. This is useful in the case of wrapper programs which may, for instance,
need to parse out one set of flags which direct the behavior of the wrapper
itself, extract a different set and pass them to program X, another for
program Y, then exec program Z with the remainder. Doing this kind of thing
on a basic <CODE>@ARGV</CODE> using indexing and splicing is do-able but
leads to spaghetti code and potential off-by-one errors.

<LI><STRONG><A NAME="item_EXTRA">EXTRA FEATURES</A></STRONG>
<P>
The <EM>execution methods</EM>  <CODE>system, exec, and qx</CODE> extend their Perl builtin analogues in a few ways, for example:

<OL>
<LI><STRONG><A NAME="item_An_xargs_like_capability_">An xargs-like capability.</A></STRONG>
<LI><STRONG><A NAME="item_UNIX_like_exec_behavior_on_Win">UNIX-like exec() behavior on Windows.</A></STRONG>
<LI><STRONG><A NAME="item_Automatic_quoting_of_system_on">Automatic quoting of system() on Win32 and qx() everywhere</A></STRONG>
<LI><STRONG><A NAME="item_Automatic_globbing_primarily_fo">Automatic globbing (primarily for Windows)</A></STRONG>
<LI><STRONG><A NAME="item_Automatic_chomping_">Automatic chomping.</A></STRONG>
<LI><STRONG><A NAME="item_Pathname_normalization_">Pathname normalization.</A></STRONG>
</OL>
</UL>
<P>
All of these behaviors can be toggled, either as class or instance
attributes. See EXECUTION ATTRIBUTES below.

<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
An Argv object treats a command line as 3 separate entities: the
<EM>program</EM>, the <EM>options</EM>, and the <EM>args</EM>. The <EM>options</EM> may be futher subdivided into user-defined <EM>option sets</EM> by use of the
<CODE>optset</CODE> method. When one of the <EM>execution methods</EM> is called, the parts are reassmbled into a single list and passed to the
underlying Perl execution function.

<P>
Compare this with the way Perl works natively, keeping the 0th element of
the argv in <CODE>$0</CODE> and the rest in <CODE>@ARGV</CODE>.

<P>
By default there's one option set, known as the <EM>anonymous option
set</EM>, whose name is the null string. All parsed options go there. The advanced
user can define more option sets, parse options into them according to
Getopt::Long-style descriptions, query or set the parsed values, and then
reassemble them in any way desired at exec time. Declaring an option set
automatically generates a set of methods for manipulating it (see below).

<P>
All argument-parsing within Argv is done via Getopt::Long.

<P>
<HR>
<H1><A NAME="FUNCTIONAL_INTERFACE">FUNCTIONAL INTERFACE</A></H1>
<P>
Because the extensions to <CODE>system/exec/qx</CODE> described here may be useful for aid in writing portable programs, they're
made available for export as traditional functions. Thus:

<P>
<PRE>    use Argv qw(system exec qv);
</PRE>
<P>
will override the Perl builtins. There is no way to override the operator <CODE>qx()</CODE> so an alias <CODE>qv()</CODE> is provided.

<P>
<HR>
<H1><A NAME="CONSTRUCTOR">CONSTRUCTOR</A></H1>
<P>
<PRE>    my $obj = Argv-&gt;new(@list)
</PRE>
<P>
The <CODE>@list</CODE> is what will be parsed/executed/etc by subsequent method calls. During
initial construction, the first element of the list is separated off as the <EM>program</EM>; the rest is lumped together as part of the <EM>args</EM> until and unless option parsing is done, in which case matched options are
shifted into collectors for their various <EM>option
sets</EM>. You can also create a ``predigested'' instance by passing any or all of
the prog, opt, or arg parts as array refs. E.g.

<P>
<PRE>    Argv-&gt;new([qw(cvs ci)], [qw(-l -n)], qw(file1 file2 file3));
</PRE>
<P>
Predigested options are placed in the default (anonymous) option set.

<P>
The constructor can be used as a class or instance method. When a new
instance is generated from an existing one, the new one is a copy of its
progenitor.

<P>
The first argument to <CODE>new()</CODE> may be a hash-ref, which will be used to set <EM>execution attributes</EM> at construction time. I.e.:

<P>
<PRE>        my $argv = Argv-&gt;new({autochomp =&gt; 1, stderr =&gt; 0}, @ARGV);
</PRE>
<P>
<HR>
<H1><A NAME="METHODS">METHODS</A></H1>
<P>
<HR>
<H2><A NAME="INSTANCE_METHODS">INSTANCE METHODS</A></H2>
<UL>
<LI><STRONG><A NAME="item_prog">prog()</A></STRONG>
<P>
Returns or sets the name of the program (the <CODE>&quot;argv[0]&quot;</CODE>). This can be a list, e.g. <CODE>qw(rcs co)</CODE> or an array reference.

<LI><STRONG><A NAME="item_args">args()</A></STRONG>
<P>
Returns or sets the list of operands (aka arguments). As above, it may be
passed a list or an array reference. If called in a void context and
without args, the effect is to set the list of operands to <CODE>()</CODE>.

<LI><STRONG><A NAME="item_optset">optset(&lt;list-of-set-names&gt;);</A></STRONG>
<P>
For each name <EM>NAME</EM> in the parameter list, an <EM>option set</EM> of that name is declared and 3 new methods are registered dynamically:
<CODE>parse&lt;EM&gt;NAME&lt;/EM&gt;(), opts&lt;EM&gt;NAME&lt;/EM&gt;(), and flag&lt;EM&gt;NAME&lt;/EM&gt;()</CODE>. These methods are described below: note that the <EM>anonymous option set</EM> (see <EM>OPTION
SETS</EM>) is predefined, so the methods <CODE>parse(), opts(), and flag()</CODE> are always available. Most users won't need to define any other sets. Note
that option-set names are forced to upper case. E.g.:

<P>
<PRE>        $obj-&gt;optset('FOO');
</PRE>
<LI><STRONG><A NAME="item_parseNAME">parseNAME(...option-descriptions...)</A></STRONG>
<P>
Takes a list of option descriptions and uses Getopt::Long::GetOptions() to
parse them out of the current argv <STRONG>and into option set <EM>NAME</EM></STRONG>. The opt-descs are exactly as supported by parse<EM>FOO</EM>() are exactly the same as those described for Getopt::Long, except that no
linkage argument is allowed. E.g.:

<P>
<PRE>        $obj-&gt;parseFOO(qw(file=s list=s@ verbose));
</PRE>
<LI><STRONG><A NAME="item_optsNAME">optsNAME()</A></STRONG>
<P>
Returns or sets the list of options in the <STRONG>option set <EM>NAME</EM></STRONG>.

<LI><STRONG><A NAME="item_flagNAME">flagNAME()</A></STRONG>
<P>
Sets or gets the value of a flag in the appropriate optset, e.g.:

<P>
<PRE>        print &quot;blah blah blah\n&quot; if $obj-&gt;flagFOO('verbose');
        $obj-&gt;flagFOO('verbose' =&gt; 1);
</PRE>
<LI><STRONG><A NAME="item_extract">extract</A></STRONG>
<P>
Takes an <EM>optset</EM> name and a list of option descs; creates the named optset, extracts any of
the named options, places them in the specified optset, and returns them.

<LI><STRONG><A NAME="item_quote">quote(@list)</A></STRONG>
<P>
Protects the argument list against exposure to a shell by quoting each
element. This method is invoked automatically by the <EM>system</EM> method on Windows platforms, where the underlying <EM>system</EM> primitive always uses a shell, and by the <EM>qx</EM> method on all platforms since it invokes a shell on all platforms.

<P>
The automatic use of <EM>quote</EM> can be turned off via the <EM>autoquote</EM>
method (see).

<P>
IMPORTANT: this method quotes its argument list IN PLACE. In other words,
it may modify its arguments.

<LI><STRONG><A NAME="item_glob">glob</A></STRONG>
<P>
Expands the argument list using the Perl <EM>glob</EM> builtin. Primarily useful on Windows where the invoking shell does not do
this for you.

<P>
Automatic use of <EM>glob</EM> on Windows can be enabled via the <EM>autoglob</EM>
method (vide infra).

</UL>
<P>
<HR>
<H2><A NAME="EXECUTION_METHODS">EXECUTION METHODS</A></H2>
<P>
The three methods below are direct analogues of the Perl builtins. They
simply reassemble a command line from the <EM>prog</EM>, <EM>opts</EM>, and
<EM>args</EM> parts according to the option-set rules described below and invoke their
builtin equivalent on it.

<UL>
<LI><STRONG><A NAME="item_system">system([&lt;optset-list&gt;])</A></STRONG>
<P>
Reassembles the argv and invokes <CODE>system().</CODE> Return value and
value of $?, $!, etc. are just as described in <EM>perlfunc/"system"</EM>



<P>
Arguments to this method determine which of the parsed option-sets will be
used in the executed argv. If passed no arguments, <CODE>$obj-</CODE>system&gt; uses the value of the 'dfltsets' attribute as the list of
desired sets. The default value of 'dfltsets' is the anonymous option set.

<P>
An option set may be requested by passing its name (with an optional
leading '+') or explicitly rejected by using its name with a leading '-'.
Thus, given the existence of option sets <EM>ONE, TWO, and THREE</EM>, the following are legal:

<P>
<PRE>    $obj-&gt;system;                       # use the anonymous set only
    $obj-&gt;system('+');                  # use all option sets
    $obj-&gt;system(qw(ONE THREE);         # use sets ONE and THREE
</PRE>
<P>
The following sequence would also use sets ONE and THREE.

<P>
<PRE>    $obj-&gt;dfltsets({ONE =&gt; 1, THREE =&gt; 1});
    $obj-&gt;system;
</PRE>
<P>
while this would use all parsed options:

<P>
<PRE>    $obj-&gt;dfltsets({'+' =&gt; 1});
    $obj-&gt;system;
</PRE>
<P>
and this would set the default to none class-wide, and then use it:

<P>
<PRE>    $obj-&gt;dfltsets({'-' =&gt; 1});
    $obj-&gt;system;
</PRE>
<P>
By default the <CODE>$obj-</CODE>system&gt; method autoquotes its arguments <EM>iff</EM>
the platform is Windows and the arguments are a list, because in this case
a shell is always used. This behavior can be toggled with
<CODE>$obj-</CODE>autoquote&gt;.  <EM>Note: if and when Perl 5.6 fixes this "bug",
Argv will be changed to examine the value of $]</EM>.

<LI><STRONG><A NAME="item_exec">exec()</A></STRONG>
<P>
Similar to <EM>system</EM> above, but never returns. On Windows, it blocks until the new process
finishes for a more UNIX-like behavior than the <EM>exec</EM> implemented by the C runtime library on Windows, if the <STRONG>execwait</STRONG> attribute is set. This is actually implemented as

<P>
<PRE>    exit $obj-&gt;system(LIST);
</PRE>
<P>
and thus all <CODE>system</CODE> shell-quoting issues apply

<P>
Option sets are handled as described in <EM>system</EM> above.

<LI><STRONG><A NAME="item_qx">qx()</A></STRONG>
<P>
Same semantics as described in <EM>perlfunc/"qx"</EM> but has the capability to process only a set number of arguments at a time
to avoid exceeding the shell's line-length limit. This value is settable
with the
<EM>qxargs</EM> method.

<P>
Also, if <EM>autoquote</EM> is set the arguments are quoted to protect them against the
platform-standard shell <EM>on all platforms</EM>. 

<P>
Option sets are handled as described in <EM>system</EM> above.

</UL>
<P>
<HR>
<H2><A NAME="EXECUTION_ATTRIBUTES">EXECUTION ATTRIBUTES</A></H2>
<P>
The behavior of the <EM>execution methods</EM>  <CODE>system, exec, and qx</CODE> is governed by a set of <EM>execution attributes</EM>, which are in turn manipulated via a set of eponymous methods. These
methods are auto-generated and thus share certain common characteristics:

<UL>
<LI><STRONG><A NAME="item_Translucency">Translucency</A></STRONG>
<P>
They can all be invoked as class or instance methods. If used as an
instance method the attribute is set only on that object; if used on the
class it sets or gets the default for all instances which haven't
overridden it. This is inspired by the section on <EM>translucent
attributes</EM> in Tom Christiansen's <EM>perltootc</EM> tutorial.

<LI><STRONG><A NAME="item_Class">Class Defaults</A></STRONG>
<P>
Each attribute has a default which may be overridden with an environment
variable by prepending the class name, e.g. ARGV_QXARGS=256 or
ARGV_STDERR=0;

<LI><STRONG><A NAME="item_Context">Context Sensitivity</A></STRONG>
<P>
The attribute value is always a scalar. If a value is passed it becomes the
new value of the attribute and the object or class is returned. If no value
is passed <EM>and there is a valid return
context</EM>, the current value is returned. In a void context with no parameter, the
attribute value is set to 1.

<LI><STRONG><A NAME="item_Stickiness">Stickiness</A></STRONG>
<P>
A subtlety: if an <EM>execution attribute</EM> is set in a void context, that attribute is <EM>"sticky"</EM>, i.e. it retains its state until explicitly changed. But if <EM>a new value is provided</EM> and the context is not void, the new value is <STRONG>temporary</STRONG>. It lasts until the next <EM>execution
method</EM> (<CODE>system, exec, or qx</CODE>) invocation, after which the previous value is restored. This feature
allows locutions like this:

<P>
<PRE>        $argv-&gt;cmd('date')-&gt;stderr(1)-&gt;system;
</PRE>
<P>
Assuming that the <CODE>$argv</CODE> object already exists and has a set of attributes; we can override one of
them at execution time. More examples:

<P>
<PRE>        $argv-&gt;stdout(1);          # set attribute, sticky
        $argv-&gt;stdout;             # same as above
        $foo = $argv-&gt;stdout;      # get attribute value
        $obj = $argv-&gt;stdout(1);   # set to 1 (temporary), return $argv
</PRE>
</UL>
<UL>
<LI><STRONG><A NAME="item_autochomp">autochomp</A></STRONG>
<P>
All data returned by the <CODE>qx</CODE> method is chomped first. Unset by default.

<LI><STRONG><A NAME="item_autofail">autofail</A></STRONG>
<P>
When set, the program will exit immediately if either of the <CODE>system</CODE>
or <CODE>qx</CODE> methods would return a nonzero status. Unset by default.

<LI><STRONG><A NAME="item_autoglob">autoglob</A></STRONG>
<P>
If set, the <CODE>glob()</CODE> function is applied to the operands (<CODE>$self-</CODE>args&gt;) on Windows only. Unset by default.

<LI><STRONG><A NAME="item_autoquote">autoquote</A></STRONG>
<P>
If set, the operands are automatically quoted against shell expansion
before <CODE>system()</CODE> on Windows and <CODE>qx()</CODE> on all platforms (since <CODE>qx</CODE>
always invokes a shell, and <CODE>system()</CODE> always does so on Windows). Set by default.

<LI><STRONG><A NAME="item_dbglevel">dbglevel</A></STRONG>
<P>
Sets the debug level. Level 0 (the default) is no debugging, 1 prints each
command before executing it, and higher levels offer progressively more
output.

<LI><STRONG><A NAME="item_dfltsets">dfltsets</A></STRONG>
<P>
Sets and/or returns the default set of <EM>option sets</EM> to be used in building up the command line at execution time. The
default-default is the <EM>anonymous option set</EM>. <EM>Note: this method takes a <STRONG>hash
reference</STRONG> as its optional argument and returns a hash ref as well</EM>. The selected sets are represented by the hash keys; the values are
meaningless.

<LI><STRONG><A NAME="item_execwait">execwait</A></STRONG>
<P>
If set, <CODE>$self-</CODE>exec&gt; on Windows blocks until the new process is finished for a more
consistent UNIX-like behavior than the traditional Win32 Perl port. Perl
just uses the Windows <CODE>exec()</CODE> routine, which runs the new
process in the background. Set by default.

<LI><STRONG><A NAME="item_pathnorm">pathnorm</A></STRONG>
<P>
If set, normalizes pathnames to their native format just before executing.
This is set by default on Windows only, thus converting /x/y/z to \x\y\z.

<LI><STRONG><A NAME="item_noexec">noexec</A></STRONG>
<P>
Analogous to the <CODE>-n</CODE> flag to <EM>make</EM>; prints what would be executed without executing anything.

<LI><STRONG><A NAME="item_qxargs">qxargs</A></STRONG>
<P>
You can set a maximum number of arguments to be processed at a time,
allowing you to blithely invoke e.g. <CODE>$obj-</CODE>qx&gt; on a list of any size without fear of exceeding your shell's limits.
A per-platform default is set; this method allows it to be changed. A value
of 0 suppresses the behavior.

<LI><STRONG><A NAME="item_systemxargs">systemxargs</A></STRONG>
<P>
Analogous to <EM>qxargs</EM> but turned off by default. The reason is that
<CODE>qx()</CODE> is typically used to <EM>read</EM> data whereas <CODE>system()</CODE> is more often used to make stateful changes. Consider that ``ls foo bar''
produces the same result if broken up into ``ls foo'' and ``ls bar'' but
the same cannot be said for ``mv foo bar''.

<LI><STRONG><A NAME="item_stdout">stdout</A></STRONG>
<P>
Default value is true which has no effect. A false value, e.g:

<P>
<PRE>    $obj-&gt;stdout(0);
</PRE>
<P>
causes STDOUT to be closed during invocation of any of the <EM>execution
methods</EM>  <CODE>system, exec, and qx</CODE>, and restored when they finish. A fancy (and portable) way of saying
1&gt;/dev/null without needing a shell.

<LI><STRONG><A NAME="item_stderr">stderr</A></STRONG>
<P>
As above, for STDERR.

</UL>
<UL>
<LI><STRONG><A NAME="item_attropts">attropts</A></STRONG>
<P>
The attributes above can be set via method calls (e.g.
<CODE>$obj-</CODE><CODE>dbglevel(1)&gt;)</CODE> or environment variables (ARGV_DBGLEVEL=1).
Use of the &lt;$obj-&gt;attropts&gt; method allows them to be parsed from the command line
as well, e.g. <EM>myscript -/dbglevel 1</EM>. If invoked as a class method it causes options of the same names as the
methods above to be parsed (and removed) from the current <CODE>@ARGV</CODE> and set as class attributes. As an instance method it parses and
potentially depletes the current argument vector of that object, and sets
instance attributes only. E.g.:

<P>
<PRE>    Argv-&gt;attropts;
</PRE>
<P>
would cause the script to parse the following command line:

<P>
<PRE>    script -/noexec 1 -/dbglevel 2 -flag1 -flag2 arg1 arg2 arg3 ...
</PRE>
<P>
so as to remove the <CODE>-/noexec 1 -/dbglevel 2</CODE> and set the two class attrs. The <CODE>-/</CODE> prefix is chosen to prevent conflicts with ``real'' flags. Abbreviations
are allowed as long as they're unique within the set of -/ flags.

<H1><A NAME="PORTING">PORTING</A></H1>
<P>
This module is known to work on Solaris 2.5-7 and Windows NT 4.0SP3-5, and
with perl 5.004_04 and 5.005_03. As these two platforms are quite
different, there should be no <EM>major</EM> portability issues, but please send bug reports or patches to the address
below.

<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
David Boyce &lt;<A
HREF="mailto:dsb@world.std.com">dsb@world.std.com</A>&gt;

<H1><A NAME="COPYRIGHT">COPYRIGHT</A></H1>
<P>
Copyright (c) 1999,2000 David Boyce. All rights reserved. This Perl program
is free software; you may redistribute and/or modify it under the same
terms as Perl itself.

<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
<CODE>perl(1),</CODE> Getopt::Long(3), IPC::ChildSafe(3)

</DL>
</BODY>

</HTML>
